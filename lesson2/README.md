Structure the forthcoming 
=========================

After we understood and agreed upon the requirements in the first lesson, we
need to derive a plan how to actually implement the functionality we want in our 
program. This plan is often referred to as the design or architecture of the 
software.

When writing software, a naive or brute force approach might work in small, scoped 
projects that take limited effort to be implemented. It will fail for sure, if 
you're working on a large project, that takes time to be developed, where lots of
people working on the same piece of software.

Thus we need to structure our program to break it in manageable and intelligible
parts. Even the process of thinking about the structure has some value in it. We
won't find all problems in advance, but we could at least make sure, that we have
a proper understanding of what needs to be done in terms of concrete technology.
We need to be able to transform the requirements (that don't talk much about 
technology) to structures in our program. It's also very likely that we'll find 
the requirements to be unprecise in this regard. The same functionality could 
be implemented in many different ways, thus we need to take decisions that stem
from more than the requirements. 

In some way this makes the design subject to personal preferences or experiences
that can't be generalized or judged. Despite this, there are patterns that are 
used widely throughout different programming communities or even across them. I
won't speak up for any of those patterns, guidelines or principles (here!), but
instead try to give some more rationales why it is usefull to at least follow any 
of them and why it is even more beneficial to think about which ones are actually
fitting the project.

